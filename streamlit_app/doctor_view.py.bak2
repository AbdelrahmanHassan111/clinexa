import streamlit as st
import pandas as pd
import numpy as np
import joblib
import mysql.connector
from datetime import datetime, timedelta, time
import time as time_module
import json
import google.generativeai as genai
from streamlit_chat import message
import matplotlib.pyplot as plt
import seaborn as sns
from io import BytesIO
import os
import cv2
from PIL import Image
from mri_models import process_mri_with_huggingface, apply_colormap_to_heatmap, extract_roi_measurements
import random
# Add import for visit comparison
from visit_comparison import display_visit_comparison

# Gemini API setup
API_KEY = "AIzaSyC1R-VeIuMePDZt_Z1WLluHkoq2tjWsVz8"
genai.configure(api_key=API_KEY)
model = genai.GenerativeModel("gemini-2.5-pro-exp-03-25")

# Load the ML model - use relative path
model_path = "model\\XGBoost_grid_optimized.joblib"
try:
    # Check if model file exists
    if os.path.exists(model_path):
        clf = joblib.load(model_path)
    else:
        st.warning(f"Model file not found at {model_path}. Using placeholder model for demonstration.")
        # Create a dummy classifier for demonstration purposes
        from sklearn.ensemble import XGBClassifier
        clf = XGBClassifier(n_estimators=10)
        # Set some dummy feature importances for visualization
        import numpy as np
        feature_names = get_feature_columns()
        clf.feature_importances_ = np.random.random(len(feature_names))
        clf.classes_ = np.array([0, 1, 2])  # Cognitively Normal, MCI, AD
except Exception as e:
    st.error(f"Error loading model: {e}")
    clf = None

# Database connection parameters
DB_CONFIG = {
    "host": "localhost",
    "user": "root", 
    "password": "root",
    "database": "smart_clinic"
}

# Class mapping for Alzheimer's predictions
ALZHEIMER_CLASS_MAPPING = {
    0: "Cognitively Normal",
    1: "Mild Cognitive Impairment",
    2: "Alzheimer's Disease (AD)"
}

# Direct DB Connection
def get_db_connection():
    """Create a direct database connection."""
    try:
        connection = mysql.connector.connect(**DB_CONFIG)
        return connection
    except mysql.connector.Error as e:
        st.error(f"Database connection error: {e}")
        return None

# Get the feature names required by the model
def get_feature_columns():
    """Return ordered list of feature columns required by the model"""
    return [
        "CDRSB", "mPACCdigit", "MMSE", "LDELTOTAL", "mPACCtrailsB", 
        "EcogSPPlan", "RAVLT_immediate", "FAQ", "EcogPtTotal", "Entorhinal", 
        "PTEDUCAT", "Ventricles", "Fusiform", "EcogSPOrgan", "APOE4", 
        "EcogPtLang", "FDG", "MidTemp", "TRABSCOR", "EcogSPDivatt", 
        "ADAS11", "EcogPtVisspat", "AGE", "ADAS13", "EcogSPMem", 
        "EcogPtOrgan", "ICV", "Hippocampus", "EcogSPVisspat", "MOCA", 
        "WholeBrain", "PTRACCAT", "RAVLT_learning", "DIGITSCOR", 
        "PTGENDER", "EcogSPTotal", "RAVLT_perc_forgetting", "ABETA", 
        "ADASQ4", "EcogSPLang", "EcogPtMem", "EcogPtDivatt", "RAVLT_forgetting"
    ]

# Get feature descriptions for tooltips
def get_feature_descriptions():
    """Return a dictionary mapping feature names to their descriptions"""
    return {
        # Cognitive assessments
        "CDRSB": "Clinical Dementia Rating Sum of Boxes - Clinical scale measuring disease severity (0-18, higher is worse)",
        "MMSE": "Mini-Mental State Examination - Global cognitive test (0-30, higher is better)",
        "MOCA": "Montreal Cognitive Assessment - Global cognitive test (0-30, higher is better)",
        "ADAS11": "Alzheimer's Disease Assessment Scale (11-item) - Cognitive test (0-70, higher is worse)",
        "ADAS13": "Alzheimer's Disease Assessment Scale (13-item) - Cognitive test (0-85, higher is worse)",
        "FAQ": "Functional Activities Questionnaire - Functional assessment (0-30, higher is worse)",
        
        # Memory tests
        "RAVLT_immediate": "Rey Auditory Verbal Learning Test - Immediate recall score (higher is better)",
        "RAVLT_learning": "Rey Auditory Verbal Learning Test - Learning score (higher is better)",
        "RAVLT_forgetting": "Rey Auditory Verbal Learning Test - Forgetting score (higher is worse)",
        "RAVLT_perc_forgetting": "Rey Auditory Verbal Learning Test - Percent forgetting (higher is worse)",
        "LDELTOTAL": "Logical Memory delayed recall - Delayed paragraph recall (higher is better)",
        
        # Brain volume measurements
        "Hippocampus": "Hippocampal volume in mm¬≥ - Critical for memory formation (higher is better)",
        "Entorhinal": "Entorhinal cortex volume in mm¬≥ - Important for memory (higher is better)",
        "Fusiform": "Fusiform gyrus volume in mm¬≥ - Involved in visual recognition (higher is better)",
        "MidTemp": "Middle temporal gyrus volume in mm¬≥ - Language processing (higher is better)",
        "Ventricles": "Ventricular volume in mm¬≥ - Filled with cerebrospinal fluid (higher is worse)",
        "WholeBrain": "Whole brain volume in mm¬≥ - Overall brain size (higher is better)",
        
        # Biomarkers
        "ABETA": "Amyloid-Œ≤ (AŒ≤) levels in CSF - Key biomarker for Alzheimer's (higher is better)",
        "TAU": "Total Tau protein levels in CSF - Marker of neuronal damage (higher is worse)",
        "PTAU": "Phosphorylated Tau levels in CSF - Marker of tau tangles (higher is worse)",
        "APOE4": "Number of APOE Œµ4 alleles - Genetic risk factor (0, 1, or 2; higher is worse risk)",
        
        # Demographics
        "AGE": "Patient age in years at time of visit",
        "PTGENDER": "Patient gender (1=male, 2=female)",
        "PTEDUCAT": "Patient years of education completed"
    }

# Get existing patient features or None
def get_patient_features(patient_id):
    conn = get_db_connection()
    if not conn:
        return None
    
    cursor = conn.cursor(dictionary=True)
    try:
        cursor.execute("SELECT * FROM alzheimer_features WHERE patient_id = %s", (patient_id,))
        features = cursor.fetchone()
        cursor.close()
        conn.close()
        return features
    except mysql.connector.Error as e:
        st.error(f"Error fetching patient features: {e}")
        cursor.close()
        conn.close()
        return None

# Prediction function
def predict_alzheimer(input_data):
    if clf is None:
        return "Error", 0
    
    try:
        # Get feature columns in the correct order
        feature_columns = get_feature_columns()
        
        # Create a properly ordered feature array with exactly 43 features
        feature_array = np.zeros(len(feature_columns))
        for i, feature in enumerate(feature_columns):
            if feature in input_data:
                feature_array[i] = input_data[feature]
        
        # Log the features being used for prediction
        st.session_state.last_feature_array = feature_array
                
        # Make prediction using the model
        prediction = clf.predict([feature_array])[0]
        
        # Handle different model types
        if hasattr(clf, 'predict_proba'):
            probabilities = clf.predict_proba([feature_array])[0]
        else:
            # Create fake probabilities for dummy model
            probabilities = np.zeros(3)
            probabilities[prediction] = 0.8  # High confidence for predicted class
            remaining = 0.2 / (len(probabilities) - 1)
            for i in range(len(probabilities)):
                if i != prediction:
                    probabilities[i] = remaining
        
        confidence = max(probabilities)
        
        # Store all probabilities in session state for visualization
        st.session_state.last_probabilities = probabilities
        st.session_state.last_prediction_classes = clf.classes_
        
        # Map integer prediction to string prediction for backwards compatibility
        pred_mapping = {0: "Nondemented", 1: "Converted", 2: "Demented"}
        if isinstance(prediction, (int, np.integer)):
            prediction = pred_mapping.get(prediction, "Unknown")
        
        return prediction, confidence
    except Exception as e:
        st.error(f"Error making prediction: {e}")
        return "Error", 0

# Store features in database
def store_features(patient_id, feature_data):
    conn = get_db_connection()
    if not conn:
        return False
    
    cursor = conn.cursor()
    try:
        # Check if patient already has features
        cursor.execute("SELECT feature_id FROM alzheimer_features WHERE patient_id = %s", (patient_id,))
        existing = cursor.fetchone()
        
        if existing:
            # Update existing features
            set_clause = ", ".join([f"{key} = %s" for key in feature_data.keys()])
            values = list(feature_data.values())
            values.append(patient_id)  # For WHERE clause
            
            cursor.execute(f"UPDATE alzheimer_features SET {set_clause} WHERE patient_id = %s", values)
            conn.commit()
            cursor.close()
            conn.close()
            return True
        else:
            # Insert new features
            columns = ", ".join(["patient_id"] + list(feature_data.keys()))
            placeholders = ", ".join(["%s"] * (len(feature_data) + 1))
            values = [patient_id] + list(feature_data.values())
            
            cursor.execute(f"INSERT INTO alzheimer_features ({columns}) VALUES ({placeholders})", values)
            conn.commit()
            cursor.close()
            conn.close()
            return True
    except mysql.connector.Error as e:
        st.error(f"Error storing features: {e}")
        cursor.close()
        conn.close()
        return False

# Store prediction in database
def store_prediction(patient_id, features, prediction, confidence):
    conn = get_db_connection()
    if not conn:
        return False
    
    cursor = conn.cursor()
    try:
        now = datetime.now()
        today = now.date()
        
        # Convert any numpy values to standard Python types
        converted_features = {}
        for key, value in features.items():
            if hasattr(value, "dtype"):  # Check if it's a numpy type
                converted_features[key] = value.item()  # Convert numpy value to Python scalar
            else:
                converted_features[key] = value
                
        features_json = json.dumps(converted_features)
        
        # Make sure prediction and confidence are also standard Python types
        prediction = str(prediction)
        confidence = float(confidence)
        
        # Check if a prediction already exists for this patient today
        cursor.execute("""
            SELECT analysis_id FROM alzheimers_analysis 
            WHERE patient_id = %s AND DATE(analyzed_at) = %s
        """, (patient_id, today))
        
        existing_analysis = cursor.fetchone()
        
        # Make sure to consume all results
        while cursor.fetchone() is not None:
            pass
        
        if existing_analysis:
            # Update existing prediction
            analysis_id = existing_analysis[0]
            cursor.execute("""
                UPDATE alzheimers_analysis 
                SET input_features = %s, prediction = %s, confidence_score = %s, analyzed_at = %s
                WHERE analysis_id = %s
            """, (features_json, prediction, confidence, now, analysis_id))
            
            conn.commit()
            st.info(f"Updated existing prediction from today (ID: {analysis_id}).")
            return analysis_id
        else:
            # Insert new prediction
            cursor.execute("""
                INSERT INTO alzheimers_analysis 
                (patient_id, input_features, prediction, confidence_score, analyzed_at)
                VALUES (%s, %s, %s, %s, %s)
            """, (patient_id, features_json, prediction, confidence, now))
            
            conn.commit()
            analysis_id = cursor.lastrowid  # Get the ID of the newly inserted analysis
            return analysis_id
    except mysql.connector.Error as e:
        st.error(f"Error storing prediction: {e}")
        return False
    finally:
        # Always close cursor and connection in finally block
        if cursor:
            cursor.close()
        if conn:
            conn.close()

# Get patient medical records
def get_patient_records(patient_id):
    conn = get_db_connection()
    if not conn:
        return []
    
    cursor = conn.cursor(dictionary=True)
    try:
        cursor.execute("""
            SELECT record_id, diagnosis, visit_date, notes
            FROM medical_records
            WHERE patient_id = %s
            ORDER BY visit_date DESC
        """, (patient_id,))
        
        records = cursor.fetchall()
        cursor.close()
        conn.close()
        return records
    except mysql.connector.Error as e:
        st.error(f"Error fetching medical records: {e}")
        cursor.close()
        conn.close()
        return []

# Get patient personal information
def get_patient_info(patient_id):
    conn = get_db_connection()
    if not conn:
        return None
    
    cursor = conn.cursor(dictionary=True)
    try:
        cursor.execute("""
            SELECT * FROM patients WHERE patient_id = %s
        """, (patient_id,))
        
        patient_info = cursor.fetchone()
        cursor.close()
        conn.close()
        return patient_info
    except mysql.connector.Error as e:
        st.error(f"Error fetching patient info: {e}")
        cursor.close()
        conn.close()
        return None

# Add medical record for patient
def add_medical_record(patient_id, diagnosis, notes):
    conn = get_db_connection()
    if not conn:
        return False
    
    cursor = conn.cursor()
    try:
        visit_date = datetime.now().date()
        
        cursor.execute("""
            INSERT INTO medical_records (patient_id, diagnosis, visit_date, notes)
            VALUES (%s, %s, %s, %s)
        """, (patient_id, diagnosis, visit_date, notes))
        
        conn.commit()
        cursor.close()
        conn.close()
        return True
    except mysql.connector.Error as e:
        st.error(f"Error adding medical record: {e}")
        cursor.close()
        conn.close()
        return False

# Get previous analyses for a patient
def get_patient_analyses(patient_id):
    conn = get_db_connection()
    if not conn:
        return []
    
    cursor = conn.cursor(dictionary=True)
    try:
        cursor.execute("""
            SELECT analysis_id, prediction, confidence_score, analyzed_at
            FROM alzheimers_analysis
            WHERE patient_id = %s
            ORDER BY analyzed_at DESC
        """, (patient_id,))
        
        analyses = cursor.fetchall()
        cursor.close()
        conn.close()
        return analyses
    except mysql.connector.Error as e:
        st.error(f"Error fetching analyses: {e}")
        cursor.close()
        conn.close()
        return []

# Save chat message
def save_chat_message(patient_id, doctor_id, message, sender):
    conn = get_db_connection()
    if not conn:
        return False
    
    cursor = conn.cursor()
    try:
        # First check if the doctor_id exists in the doctors table
        cursor.execute("SELECT COUNT(*) FROM doctors WHERE doctor_id = %s", (doctor_id,))
        doctor_exists = cursor.fetchone()[0] > 0
        
        # If doctor does not exist, we need to create a doctor entry using the user's ID
        if not doctor_exists:
            # Get user info
            cursor.execute("SELECT username FROM users WHERE id = %s", (doctor_id,))
            user_result = cursor.fetchone()
            
            if user_result:
                username = user_result[0]
                # Create a doctor entry with the same ID as the user
                try:
                    cursor.execute("""
                        INSERT INTO doctors (doctor_id, full_name, specialization, email, phone_number)
                        VALUES (%s, %s, %s, %s, %s)
                    """, (doctor_id, username, "General Practitioner", f"{username}@clinic.com", "N/A"))
                    conn.commit()
                    st.info(f"Created doctor profile for user {username}")
                except mysql.connector.Error:
                    # If we can't create a doctor with the same ID, return error
                    st.error("Cannot save message: Doctor profile does not exist")
                    cursor.close()
                    conn.close()
                    return False
            else:
                st.error("User not found")
                cursor.close()
                conn.close()
                return False
                
        # Now we can insert the chat message
        now = datetime.now()
        
        # Convert sender from 'Doctor'/'Assistant' to 'doctor'/'model' for database
        db_sender = 'doctor' if sender == 'Doctor' else 'model'
        
        cursor.execute("""
            INSERT INTO chat_logs (patient_id, doctor_id, message, sender, timestamp)
            VALUES (%s, %s, %s, %s, %s)
        """, (patient_id, doctor_id, message, db_sender, now))
        
        conn.commit()
        cursor.close()
        conn.close()
        return True
    except mysql.connector.Error as e:
        st.error(f"Error saving chat message: {e}")
        cursor.close()
        conn.close()
        return False

# Get previous chat history
def get_chat_history(patient_id, doctor_id):
    conn = get_db_connection()
    if not conn:
        return []
    
    cursor = conn.cursor(dictionary=True)
    try:
        cursor.execute("""
            SELECT message, sender, timestamp
            FROM chat_logs
            WHERE patient_id = %s AND doctor_id = %s
            ORDER BY timestamp ASC
        """, (patient_id, doctor_id))
        
        chat_logs = cursor.fetchall()
        cursor.close()
        conn.close()
        
        # Convert to format expected by session state
        history = []
        for log in chat_logs:
            # Convert from database 'doctor'/'model' to UI 'You'/'Assistant'
            sender_name = "You" if log["sender"] == "doctor" else "Assistant"
            history.append((sender_name, log["message"]))
        
        return history
    except mysql.connector.Error as e:
        st.error(f"Error fetching chat history: {e}")
        cursor.close()
        conn.close()
        return []

# Generate plot of feature importance
def generate_feature_importance_plot():
    if not hasattr(clf, 'feature_importances_'):
        return None
    
    features = get_feature_columns()
    importances = clf.feature_importances_
    
    # Sort features by importance
    indices = np.argsort(importances)[::-1]
    
    # Take top 10 most important features (reduced from 15)
    top_indices = indices[:10]
    top_features = [features[i] for i in top_indices]
    top_importances = [importances[i] for i in top_indices]
    
    # Create plot with minimal size
    plt.figure(figsize=(1.5, 0.8), dpi=150)
    plt.title('Top 10 Features', fontsize=4)
    plt.barh(range(len(top_indices)), top_importances, align='center', height=0.4)
    plt.yticks(range(len(top_indices)), top_features, fontsize=2)
    plt.xticks(fontsize=2)
    plt.xlabel('Importance', fontsize=3)
    
    # Save plot to buffer
    buf = BytesIO()
    plt.savefig(buf, format='png', bbox_inches='tight', dpi=150)
    buf.seek(0)
    plt.close()
    
    return buf

# Doctor panel main content
def doctor_panel():
    # Initialize doctor ID from session state
    doctor_id = st.session_state.get("user_id", 1)
    
    # Sidebar menu
    with st.sidebar:
        st.title("üßë‚Äç‚öïÔ∏è Doctor Dashboard")
        
        # Navigation
        page = st.radio("Navigation", [
            "üë®‚Äçüë©‚Äçüëß‚Äçüë¶ Patient Management",
            "üß† Alzheimer's Analysis",
            "üìã Medical Records",
            "üí¨ AI Assistant",
            "üìä Analytics"
        ])
        
        # Logout button
        if st.button("üö™ Sign Out"):
            st.session_state.clear()
            st.success("You have been signed out.")
            st.rerun()
    
    # Main content area
    conn = get_db_connection()
    if not conn:
        st.error("Could not connect to database")
        return
    
    cursor = conn.cursor()

    # Patient selection
    st.subheader("Patient Selection")
    col1, col2 = st.columns([3, 1])
    
    with col1:
        search_term = st.text_input("üîç Search Patient by Name or ID")
    
    with col2:
        add_new = st.button("‚ûï Add New Patient")
    
    if add_new:
        st.session_state.show_add_patient = True
    
    # Display add patient form if flag is set
    if st.session_state.get("show_add_patient", False):
        with st.expander("Add New Patient", expanded=True):
            added = add_patient()
            if added:
                st.session_state.show_add_patient = False
                st.rerun()
            
            if st.button("Cancel"):
                st.session_state.show_add_patient = False
                st.rerun()
    
    # Get patient list based on search term
    if search_term:
        try:
            cursor.execute("""
                SELECT patient_id, full_name, birth_date, gender, contact_info FROM patients
                WHERE full_name LIKE %s OR patient_id LIKE %s
            """, (f"%{search_term}%", f"%{search_term}%"))
            patients = cursor.fetchall()
        except mysql.connector.Error as e:
            st.error(f"Error searching patients: {e}")
            patients = []
    else:
        try:
            cursor.execute("SELECT patient_id, full_name, birth_date, gender, contact_info FROM patients ORDER BY full_name")
            patients = cursor.fetchall()
        except mysql.connector.Error as e:
            st.error(f"Error fetching patients: {e}")
            patients = []

    if not patients:
        st.warning("No patients found. Please add patients first.")
        cursor.close()
        conn.close()
        return
    
    # Create patient selection cards
    st.markdown("### Select a Patient to Continue")
    patient_cols = st.columns(3)
    
    patient_dict = {}
    for i, (pid, name, birthdate, gender, contact) in enumerate(patients):
        col = patient_cols[i % 3]
        with col:
            age = datetime.now().year - birthdate.year if birthdate else "N/A"
            card = f"""
            <div style="padding: 10px; border-radius: 5px; border: 1px solid #ddd; margin: 5px 0;">
                <h4>{name}</h4>
                <p>ID: {pid} | Age: {age} | Gender: {gender}</p>
                <p>Contact: {contact or 'N/A'}</p>
            </div>
            """
            st.markdown(card, unsafe_allow_html=True)
            patient_dict[name] = pid
            if st.button(f"Select {name}", key=f"btn_{pid}"):
                st.session_state.selected_patient = pid
                st.session_state.selected_patient_name = name
                st.rerun()
    
    # If no patient is selected, stop here
    if "selected_patient" not in st.session_state:
        cursor.close()
        conn.close()
        return
    
    # Get selected patient ID and information
    patient_id = st.session_state.selected_patient
    patient_info = get_patient_info(patient_id)
    
    if not patient_info:
        st.error("Error retrieving patient information.")
        return
    
    # Display patient header
    st.markdown(f"""
    <div style="background-color: #f0f2f6; padding: 15px; border-radius: 5px; margin-bottom: 20px;">
        <h2>{patient_info['full_name']}</h2>
        <p>Patient ID: {patient_id} | Date of Birth: {patient_info['birth_date']} | Gender: {patient_info['gender']}</p>
        <p>Contact: {patient_info['contact_info'] or 'N/A'} | Address: {patient_info['address'] or 'N/A'}</p>
    </div>
    """, unsafe_allow_html=True)
    
    # Show different content based on selected page
    if page == "üë®‚Äçüë©‚Äçüëß‚Äçüë¶ Patient Management":
        display_patient_management(patient_id, patient_info)
    elif page == "üß† Alzheimer's Analysis":
        display_alzheimer_analysis(patient_id, patient_info)
    elif page == "üìã Medical Records":
        display_medical_records(patient_id, patient_info)
    elif page == "üí¨ AI Assistant":
        display_ai_assistant(patient_id, patient_info, doctor_id)
    elif page == "üìä Analytics":
        display_analytics(patient_id, patient_info)
    
    # Close database connection
    cursor.close()
    conn.close()

# Patient management functions
def add_patient():
    st.subheader("Add New Patient")
    
    # Patient form
    with st.form("patient_form"):
        full_name = st.text_input("Full Name")
        date_of_birth = st.date_input("Date of Birth")
        gender = st.selectbox("Gender", ["Male", "Female", "Other"])
        contact_number = st.text_input("Contact Number")
        email = st.text_input("Email Address")
        address = st.text_area("Address")
        
        # Form submission
        submit = st.form_submit_button("Register Patient")
        
        if submit:
            if full_name and date_of_birth and gender:
                # Connect to database
                conn = get_db_connection()
                if not conn:
                    st.error("Could not connect to database")
                    return
                
                cursor = conn.cursor()
                try:
                    # Insert patient data
                    cursor.execute("""
                        INSERT INTO patients 
                        (full_name, birth_date, gender, contact_info, email, address, created_at)
                        VALUES (%s, %s, %s, %s, %s, %s, %s)
                    """, (full_name, date_of_birth, gender, contact_number, email, address, datetime.now()))
                    
                    conn.commit()
                    st.success(f"‚úÖ Patient {full_name} registered successfully!")
                    
                    # Get the newly created patient ID for redirecting
                    patient_id = cursor.lastrowid
                    if patient_id:
                        st.session_state.selected_patient = patient_id
                        st.session_state.selected_patient_name = full_name
                    
                    cursor.close()
                    conn.close()
                    return True
                except mysql.connector.Error as e:
                    st.error(f"Error registering patient: {e}")
                    cursor.close()
                    conn.close()
                    return False
            else:
                st.warning("Please fill in all required fields (Name, Date of Birth, Gender)")
                return False
    
    return False

def view_patients():
    st.subheader("View All Patients")
    
    # Connect to database
    conn = get_db_connection()
    if not conn:
        st.error("Could not connect to database")
        return
    
    cursor = conn.cursor(dictionary=True)
    try:
        # Fetch all patients
        cursor.execute("""
            SELECT patient_id, full_name, birth_date, gender, contact_info, 
                   email, created_at 
            FROM patients
            ORDER BY created_at DESC
        """)
        
        patients = cursor.fetchall()
        cursor.close()
        conn.close()
        
        if not patients:
            st.info("No patients registered yet.")
            return
        
        # Convert to DataFrame for display
        df = pd.DataFrame(patients)
        
        # Calculate age
        df['age'] = df['birth_date'].apply(lambda x: datetime.now().year - x.year if x else 0)
        
        # Display DataFrame as a table
        st.dataframe(df, use_container_width=True)
        
        # Optionally, allow users to filter or search by name or other details
        search_term = st.text_input("Search Patients by Name")
        if search_term:
            df_filtered = df[df['full_name'].str.contains(search_term, case=False, na=False)]
            if df_filtered.empty:
                st.info(f"No patients found with name: {search_term}")
            else:
                st.dataframe(df_filtered, use_container_width=True)
        
        # Optionally, add a button to select a patient
        patient_id = st.number_input("Enter Patient ID to Select", min_value=1, step=1)
        if patient_id and patient_id in df['patient_id'].values:
            patient_info = df[df['patient_id'] == patient_id].iloc[0]
            if st.button(f"Select Patient: {patient_info['full_name']}"):
                st.session_state.selected_patient = patient_id
                st.session_state.selected_patient_name = patient_info['full_name']
                st.rerun()
                
    except Exception as e:
        st.error(f"An error occurred while fetching patients: {e}")
        cursor.close()
        conn.close()

# Display patient management page
def display_patient_management(patient_id, patient_info):
    st.header("Patient Management")
    
    col1, col2 = st.columns(2)
    
    with col1:
        st.subheader("Patient Details")
        st.markdown(f"""
        - **Full Name**: {patient_info['full_name']}
        - **Birth Date**: {patient_info['birth_date']}
        - **Age**: {datetime.now().year - patient_info['birth_date'].year}
        - **Gender**: {patient_info['gender']}
        - **Contact**: {patient_info['contact_info'] or 'Not provided'}
        - **Address**: {patient_info['address'] or 'Not provided'}
        - **Registration Date**: {patient_info['created_at']}
        """)
        
        # Edit patient information
        with st.expander("Edit Patient Information"):
            with st.form("edit_patient_form"):
                full_name = st.text_input("Full Name", value=patient_info['full_name'])
                birth_date = st.date_input("Birth Date", value=patient_info['birth_date'])
                gender = st.selectbox("Gender", ["Male", "Female", "Other"], index=["Male", "Female", "Other"].index(patient_info['gender']))
                contact = st.text_input("Contact Information", value=patient_info['contact_info'] or "")
                address = st.text_area("Address", value=patient_info['address'] or "")
                
                submit = st.form_submit_button("Update Patient Information")
                
                if submit:
                    conn = get_db_connection()
                    if conn:
                        cursor = conn.cursor()
                        try:
                            cursor.execute("""
                                UPDATE patients
                                SET full_name = %s, birth_date = %s, gender = %s, 
                                    contact_info = %s, address = %s
                                WHERE patient_id = %s
                            """, (full_name, birth_date, gender, contact, address, patient_id))
                            
                            conn.commit()
                            st.success("‚úÖ Patient information updated successfully.")
                            
                            # Update session state
                            st.session_state.selected_patient_name = full_name
                            
                            # Refresh the page
                            time_module.sleep(1)
                            st.rerun()
                        except mysql.connector.Error as e:
                            st.error(f"Error updating patient information: {e}")
                        finally:
                            cursor.close()
                            conn.close()
    
    with col2:
        # Summary statistics
        st.subheader("Patient Summary")
        
        conn = get_db_connection()
        if conn:
            cursor = conn.cursor()
            
            # Count medical records
            cursor.execute("SELECT COUNT(*) FROM medical_records WHERE patient_id = %s", (patient_id,))
            record_count = cursor.fetchone()[0]
            
            # Count Alzheimer's analyses
            cursor.execute("SELECT COUNT(*) FROM alzheimers_analysis WHERE patient_id = %s", (patient_id,))
            analysis_count = cursor.fetchone()[0]
            
            # Get most recent analysis
            cursor.execute("""
                SELECT prediction, confidence_score, analyzed_at 
                FROM alzheimers_analysis 
                WHERE patient_id = %s 
                ORDER BY analyzed_at DESC LIMIT 1
            """, (patient_id,))
            latest_analysis = cursor.fetchone()
            
            # Count appointments
            cursor.execute("""
                SELECT COUNT(*) FROM appointments 
                WHERE patient_id = %s
            """, (patient_id,))
            appointment_count = cursor.fetchone()[0]
            
            # Display stats
            col_a, col_b = st.columns(2)
            with col_a:
                st.metric("Medical Records", record_count)
                st.metric("Appointments", appointment_count)
            
            with col_b:
                st.metric("Alzheimer's Analyses", analysis_count)
                if latest_analysis:
                    status_color = {
                        "Demented": "üî¥",
                        "Nondemented": "üü¢",
                        "Converted": "üü†"
                    }.get(latest_analysis[0], "‚ö™")
                    
                    st.metric(
                        "Latest Status", 
                        f"{status_color} {latest_analysis[0]}", 
                        f"Confidence: {latest_analysis[1]:.1%}"
                    )
            
            cursor.close()
            conn.close()
        
        # Schedule appointment
        st.subheader("Schedule Appointment")
        with st.form("schedule_appointment"):
            # Get list of doctors
            conn = get_db_connection()
            doctors = []
            if conn:
                cursor = conn.cursor()
                cursor.execute("SELECT doctor_id, full_name FROM doctors ORDER BY full_name")
                doctors = cursor.fetchall()
                cursor.close()
                conn.close()
            
            # Form fields
            if doctors:
                doctor_options = {doc[1]: doc[0] for doc in doctors}
                selected_doctor = st.selectbox("Select Doctor", list(doctor_options.keys()))
                doctor_id = doctor_options[selected_doctor]
            else:
                doctor_id = st.session_state.get("user_id", 1)
                st.info("No other doctors available in system.")
            
            appt_date = st.date_input("Appointment Date", value=datetime.now().date() + timedelta(days=1))
            appt_time = st.time_input("Appointment Time", value=time(9, 0))
            appt_datetime = datetime.combine(appt_date, appt_time)
            reason = st.text_area("Reason for Visit")
            
            submit_appt = st.form_submit_button("Schedule Appointment")
            if submit_appt:
                if reason:
                    conn = get_db_connection()
                    if conn:
                        cursor = conn.cursor()
                        try:
                            cursor.execute("""
                                INSERT INTO appointments
                                (patient_id, doctor_id, appointment_date, reason, status)
                                VALUES (%s, %s, %s, %s, %s)
                            """, (patient_id, doctor_id, appt_datetime, reason, "Scheduled"))
                            
                            conn.commit()
                            st.success("‚úÖ Appointment scheduled successfully.")
                            time_module.sleep(1)
                            st.rerun()
                        except mysql.connector.Error as e:
                            st.error(f"Error scheduling appointment: {e}")
                        finally:
                            cursor.close()
                            conn.close()
                else:
                    st.warning("Please provide a reason for the appointment.")
        
        # Show upcoming appointments
        st.subheader("Upcoming Appointments")
        conn = get_db_connection()
        if conn:
            cursor = conn.cursor(dictionary=True)
            cursor.execute("""
                SELECT a.appointment_id, a.appointment_date, a.reason, a.status, d.full_name as doctor_name
                FROM appointments a
                JOIN doctors d ON a.doctor_id = d.doctor_id
                WHERE a.patient_id = %s AND a.appointment_date >= NOW()
                ORDER BY a.appointment_date ASC
            """, (patient_id,))
            
            appointments = cursor.fetchall()
            cursor.close()
            conn.close()
            
            if appointments:
                for appt in appointments:
                    with st.expander(f"üìÖ {appt['appointment_date'].strftime('%Y-%m-%d %H:%M')} - {appt['status']}"):
                        st.write(f"**Doctor:** {appt['doctor_name']}")
                        st.write(f"**Reason:** {appt['reason']}")
                        st.write(f"**Status:** {appt['status']}")
                        
                        # Allow updating the status
                        new_status = st.selectbox(
                            "Update Status",
                            ["Scheduled", "Completed", "Cancelled", "No-show"],
                            index=["Scheduled", "Completed", "Cancelled", "No-show"].index(appt['status']),
                            key=f"status_{appt['appointment_id']}"
                        )
                        
                        if st.button("Update Status", key=f"update_{appt['appointment_id']}"):
                            conn = get_db_connection()
                            if conn:
                                cursor = conn.cursor()
                                try:
                                    cursor.execute("""
                                        UPDATE appointments
                                        SET status = %s
                                        WHERE appointment_id = %s
                                    """, (new_status, appt['appointment_id']))
                                    
                                    conn.commit()
                                    st.success("‚úÖ Appointment status updated.")
                                    time_module.sleep(1)
                                    st.rerun()
                                except mysql.connector.Error as e:
                                    st.error(f"Error updating appointment status: {e}")
                                finally:
                                    cursor.close()
                                    conn.close()
            else:
                st.info("No upcoming appointments scheduled.")

# Display Alzheimer's analysis page
def display_alzheimer_analysis(patient_id, patient_info):
    st.header("üß† Alzheimer's Disease Analysis")
    
    # Get existing features for the patient if available
    existing_features = get_patient_features(patient_id)
    
    # Create feature categories for better organization
    feature_categories = {
        "Cognitive Tests": ["CDRSB", "MMSE", "MOCA", "ADAS11", "ADAS13", "FAQ"],
        "Memory Tests": ["RAVLT_immediate", "RAVLT_learning", "RAVLT_forgetting", "RAVLT_perc_forgetting", "LDELTOTAL"],
        "Functional Tests": ["TRABSCOR", "DIGITSCOR", "mPACCdigit", "mPACCtrailsB"],
        "Patient Self-Report": ["EcogPtTotal", "EcogPtMem", "EcogPtLang", "EcogPtVisspat", "EcogPtPlan", "EcogPtOrgan", "EcogPtDivatt"],
        "Study Partner Report": ["EcogSPTotal", "EcogSPMem", "EcogSPLang", "EcogSPVisspat", "EcogSPPlan", "EcogSPOrgan", "EcogSPDivatt"],
        "Brain Measurements": ["Hippocampus", "Entorhinal", "Fusiform", "MidTemp", "Ventricles", "WholeBrain", "ICV", "FDG"],
        "Biomarkers": ["ABETA", "TAU", "PTAU", "APOE4"],
        "Demographics": ["AGE", "PTGENDER", "PTEDUCAT", "PTMARRY", "PTRACCAT", "PTETHCAT"],
        "Other Assessments": ["ADASQ4"]
    }
    
    # Get feature descriptions for tooltips
    feature_descriptions = get_feature_descriptions()
    
    # Enhanced analysis with MRI
    tab1, tab2, tab3 = st.tabs(["New Analysis", "MRI Analysis", "Analysis History"])
    
    with tab1:
        # Initialize input_data dictionary to store all features
        input_data = {}
        
        st.info("Enter values for as many features as possible. Hover over feature names for descriptions.")
        
        # Use tabs for feature categories to save space
        feature_tabs = st.tabs(list(feature_categories.keys()))
        
        for i, (category, features) in enumerate(feature_categories.items()):
            with feature_tabs[i]:
                cols = st.columns(2)
                for j, feature in enumerate(features):
                    col = cols[j % 2]
                    with col:
                        # Show tooltip with feature description
                        description = feature_descriptions.get(feature, "No description available")
                        st.markdown(f"**{feature}** ‚ÑπÔ∏è")
                        st.caption(description)
                        
                        # Use existing value as default if available
                        default_value = 0.0
                        if existing_features and feature in existing_features and existing_features[feature] is not None:
                            default_value = float(existing_features[feature])
                            
                        # Input field for feature
                        value = st.number_input(
                            f"{feature}", 
                            value=default_value,
                            step=0.01,
                            format="%.2f",
                            key=f"feature_{feature}"
                        )
                        input_data[feature] = value
        
        # Add any missing features with default values
        for feature in get_feature_columns():
            if feature not in input_data:
                input_data[feature] = 0.0
                
        # Make prediction
        col1, col2, col3 = st.columns([2, 2, 1])
        with col1:
            save_only = st.button("üíæ Save Features Only")
        with col2:
            predict_button = st.button("üß† Predict Alzheimer's Status", type="primary")
        with col3:
            discard_button = st.button("‚ùå Discard")
            
        if save_only:
            # Save feature values to database without prediction
            if store_features(patient_id, input_data):
                st.success("‚úÖ Patient features saved to database")
                time_module.sleep(1)
                st.rerun()
            else:
                st.error("‚ùå Failed to save patient features")
        
        if predict_button:
            with st.spinner("Processing prediction..."):
                # Save feature values to database
                if store_features(patient_id, input_data):
                    st.success("‚úÖ Patient features saved to database")
                    
                    # Run prediction
                    prediction, confidence = predict_alzheimer(input_data)
                    
                    # Get the predicted class (0, 1, 2) from the prediction
                    # Map the class index to the class name using the mapping
                    predicted_idx = 0  # Default to 0 (Cognitively Normal)
                    if prediction == "Demented":
                        predicted_idx = 2  # Alzheimer's Disease
                    elif prediction == "Converted":
                        predicted_idx = 1  # Mild Cognitive Impairment
                    
                    # Map the class index to the class name
                    mapped_prediction = ALZHEIMER_CLASS_MAPPING.get(predicted_idx, prediction)
                    
                    # Store prediction results
                    st.session_state.last_prediction = mapped_prediction
                    st.session_state.last_confidence = confidence
                    st.session_state.last_input_data = input_data
                    
                    store_results = st.radio(
                        "Would you like to save these prediction results?",
                        options=["Yes", "No"],
                        index=0,
                        horizontal=True
                    )
                    
                    if store_results == "Yes":
                        analysis_id = store_prediction(patient_id, input_data, prediction, confidence)
                        
                        if analysis_id:
                            st.success("‚úÖ Prediction results saved")
                        else:
                            st.error("‚ùå Failed to save prediction results")
                    else:
                        st.info("Prediction results were not saved to the database")
                        
                        # Still display the results even if not saved
                        st.markdown("### Prediction Results")
        
        if discard_button:
            # Clear the input data
            st.session_state.last_prediction = None
            st.session_state.last_confidence = None
            st.session_state.last_input_data = None
            st.session_state.last_probabilities = None
            st.session_state.last_prediction_classes = None
            st.rerun()
    
    # MRI Analysis Tab
    with tab2:
        st.subheader("MRI Scan Analysis")
        
        # Create tabs for upload vs viewing
        mri_tab1, mri_tab2 = st.tabs(["Upload New Scan", "View Patient Scans"])
        
        # Upload New Scan tab
        with mri_tab1:
            st.markdown("### Upload New MRI Scan")
            
            # File uploader for MRI scan
            uploaded_file = st.file_uploader(
                "Upload MRI scan (jpg, png, or dicom)", 
                type=["jpg", "jpeg", "png", "dcm"]
            )
            
            scan_type = st.selectbox(
                "Scan Type",
                ["T1-weighted", "T2-weighted", "FLAIR", "PET", "Other"],
                index=0
            )
            
            scan_notes = st.text_area("Scan Notes", placeholder="Enter any notes about this scan...")
            
            # Show preview if file is uploaded
            if uploaded_file is not None:
                col1, col2 = st.columns([1, 1])
                
                # Save uploaded file temporarily
                temp_dir = "temp_uploads"
                os.makedirs(temp_dir, exist_ok=True)
                file_path = os.path.join(temp_dir, uploaded_file.name)
                
                with open(file_path, "wb") as f:
                    f.write(uploaded_file.getbuffer())
                
                # Display image preview
                with col1:
                    st.markdown("### Preview")
                    st.image(file_path, use_container_width=True)
                
                with col2:
                    st.markdown("### Analysis Options")
                    # Remove other model options, keep only Hugging Face
                    analysis_options = "Hugging Face Transformer"
                    st.info("Using DHEIVER/Alzheimer-MRI Transformer model for analysis")
                    
                    if st.button("Process Scan", type="primary"):
                        with st.spinner("Processing MRI scan..."):
                            # Run Hugging Face model inference
                            st.info("Running Hugging Face model analysis...")
                            from mri_models import process_mri_with_huggingface
                            
                            # Truncate scan_type to 45 characters to prevent database error
                            truncated_scan_type = scan_type[:45] if scan_type and len(scan_type) > 45 else scan_type
                            
                            results = process_mri_with_huggingface(file_path)
                            
                            if results and 'error' not in results:
                                # Display results
                                st.markdown("### Analysis Results")
                                result_cols = st.columns([1, 1])
                                
                        with result_cols[0]:
                                    prediction = results.get('prediction', 'Unknown')
                                    confidence = results.get('confidence', 0)
                                    
                                    # Format prediction with appropriate styling
                                    if "Demented" in prediction or "demented" in prediction.lower():
                                        st.error(f"**Prediction:** {prediction}")
                                    elif "Mild" in prediction or "mild" in prediction.lower():
                                        st.warning(f"**Prediction:** {prediction}")
                                    else:
                                        st.success(f"**Prediction:** {prediction}")
                                        
                                    st.info(f"**Confidence:** {confidence:.1%}")
                                    
                                    # Display all class probabilities if available
                                    if 'all_probabilities' in results:
                                        st.markdown("#### All Class Probabilities")
                                        probs = results['all_probabilities']
                                        if isinstance(probs, list):
                                            for cls in probs:
                                                if isinstance(cls, dict) and 'label' in cls and 'probability' in cls:
                                                    st.markdown(f"**{cls['label']}**: {cls['probability']:.1%}")
                                        
                                    # Extract key measurements if available
                                    if 'roi_measurements' in results:
                                        st.markdown("#### Key Brain Measurements")
                                        measurements = results['roi_measurements']
                                        
                                        key_regions = [
                                            ('hippocampus_total', 'Hippocampus', 'Critical for memory formation'),
                                            ('entorhinal_total', 'Entorhinal Cortex', 'Early site of tau pathology'),
                                            ('temporal_lobe_total', 'Temporal Lobe', 'Important for language and memory'),
                                            ('lateral_ventricles', 'Ventricles', 'Enlarged in AD')
                                        ]
                                        
                                        for key, name, desc in key_regions:
                                            if key in measurements:
                                                st.markdown(f"**{name}:** {measurements[key]:.2f} mm¬≥ ({desc})")
                        
                        with result_cols[1]:
                                    # Show visualization
                                    if 'heatmap_path' in results and results['heatmap_path'] and os.path.exists(results['heatmap_path']):
                                        st.markdown("#### Grad-CAM Visualization")
                                        st.image(results['heatmap_path'], use_container_width=True)
                                        st.caption("Heat map showing regions that influenced the model's decision (XAI)")
                                
                                # Add MRI scan description section
                                    st.markdown("### Model Interpretation of MRI Scan")
                                    with st.spinner("Generating detailed scan description..."):
                                        description = generate_mri_description(results, truncated_scan_type)
                                        st.markdown(description)
                                    # Save scan with results to database
                                    patient_id = st.session_state.selected_patient
                                    save_result = save_mri_scan(
                                        patient_id, 
                                        file_path, 
                                        truncated_scan_type, 
                                        prediction=results.get('prediction'), 
                                        confidence=results.get('confidence'), 
                                        notes=scan_notes
                                    )
                                    
                                    if save_result:
                                        st.success(f"MRI scan saved to patient record with ID #{save_result}")
                                        
                                        # Also save ROI measurements if available
                                        if 'roi_measurements' in results:
                                            try:
                                                from mri_models import save_roi_measurements
                                                measurement_id = save_roi_measurements(save_result, results['roi_measurements'])
                                                if measurement_id:
                                                    st.success(f"Brain region measurements saved with ID #{measurement_id}")
                                            except Exception as e:
                                                st.warning(f"Could not save measurements: {e}")
                                        
                                        # Offer button to add results to medical record
                                        if st.button("Add Results to Medical Records"):
                                            prediction = results.get('prediction', 'Unknown')
                                            confidence = results.get('confidence', 0)
                                            
                                            # Format medical record entry
                                            diagnosis = f"MRI Scan Analysis (Hugging Face Transformer)"
                                            notes = f"""
                                            MRI Scan Type: {truncated_scan_type}
                                            Analysis Method: Hugging Face Transformer (DHEIVER/Alzheimer-MRI)
                                            Prediction: {prediction}
                                            Confidence: {confidence:.1%}
                                            
                                            User Notes: {scan_notes}
                                            
                                            Key Measurements:
                                            """
                                            if truncated_scan_type == "axial":
                                                notes = f"Analysis of axial MRI scan shows {prediction_text} with {confidence:.1f}% confidence."
                                            else:
                                                notes = f"Analysis of {truncated_scan_type} MRI scan shows {prediction_text} with {confidence:.1f}% confidence."

                                            # Add medical record
                                            if add_medical_record(patient_id, diagnosis, notes):
                                                st.success("Results added to medical records")
                                            else:
                                                # Display error message
                                                error_msg = results.get('error', 'Unknown error occurred') if results else 'Failed to process MRI scan'
                                                st.error(f"Error processing MRI scan: {error_msg}")
